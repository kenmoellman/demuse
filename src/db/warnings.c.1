/* warnings.c - topology.c - check to make sure rooms and exits are the way they should be. */
/* $Id: warnings.c,v 1.2 1993/08/22 18:09:34 nils Exp $ */

#include <stdio.h>
#include <string.h>

#include "db.h"
#include "config.h"
#include "externs.h"

/* ===================================================================
 * Constants
 * =================================================================== */

#define MAX_WARNING_BUFFER 1024

/* ===================================================================
 * Type Definitions
 * =================================================================== */

/* Structure for topology check function table */
struct tcheck_s
{
  char *name;
  void (*func)(dbref);
};

/* ===================================================================
 * Static Variables
 * =================================================================== */

static dbref current_object = NOTHING;

/* ===================================================================
 * Forward Declarations - Individual Check Functions
 * =================================================================== */

static void complain(dbref i, char *name, char *desc);
static int lock_type(dbref i, char *str);

/* Individual topology checks */
static void ct_roomdesc(dbref i);
static void ct_onewayexit(dbref i);
static void ct_doubleexit(dbref i);
static void ct_exitmsgs(dbref i);
static void ct_exitdesc(dbref i);
static void ct_playdesc(dbref i);
static void ct_thngdesc(dbref i);
static void ct_thngmsgs(dbref i);
static void ct_exitnames(dbref i);
static void ct_nolinked(dbref i);
static void ct_security(dbref i);

/* Group check functions */
static void ct_none(dbref i);
static void ct_serious(dbref i);
static void ct_normal(dbref i);
static void ct_extra(dbref i);
static void ct_all(dbref i);

static void check_topology_on(dbref i);

/* ===================================================================
 * Check Function Table
 * =================================================================== */

static struct tcheck_s tchecks[] =
{
  /* group checks */
  {"none", ct_none},
  {"serious", ct_serious},
  {"normal", ct_normal},
  {"extra", ct_extra},
  {"all", ct_all},

  /* now the individual checks */
  {"roomdesc", ct_roomdesc},
  {"onewayexit", ct_onewayexit},
  {"doubleexit", ct_doubleexit},
  {"exitmsgs", ct_exitmsgs},
  {"exitdesc", ct_exitdesc},
  {"thngdesc", ct_thngdesc},
  {"playdesc", ct_playdesc},
  {"thngmsgs", ct_thngmsgs},
  {"exitnames", ct_exitnames},
  {"nolinked", ct_nolinked},
  {"security", ct_security},
  {NULL, NULL}
};

/* ===================================================================
 * Utility Functions
 * =================================================================== */

/**
 * Determine the type of lock (unlocked, locked, or conditional)
 * @param i Object with the lock
 * @param str Lock string to analyze
 * @return 0=unlocked, 1=locked, 2=conditional
 */
static int lock_type(dbref i, char *str)
{
  char owner_lock[64];
  char location_lock[64];
  
  if (!str || !*str)
    return 0;
  
  if (!GoodObject(i))
    return 2;
  
  /* Check for owner-only lock */
  snprintf(owner_lock, sizeof(owner_lock), "#%ld&!#%ld", 
           db[i].owner, db[i].owner);
  if (!strcmp(str, owner_lock))
    return 1;
    
  /* Check for simple owner lock */
  snprintf(owner_lock, sizeof(owner_lock), "#%ld", db[i].owner);
  if (!strcmp(str, owner_lock))
    return 1;
  
  /* Check for location lock */
  if (GoodObject(db[i].location))
  {
    snprintf(location_lock, sizeof(location_lock), "#%ld", db[i].location);
    if (!strcmp(str, location_lock))
      return 1;
  }
  
  return 2;  /* too complicated - need both messages */
}

/**
 * Report a warning to the object's owner
 * @param i Object with the problem
 * @param name Warning type name
 * @param desc Description of the problem
 */
static void complain(dbref i, char *name, char *desc)
{
  char buf[MAX_WARNING_BUFFER];
  char *x;
  char *y;
  
  if (!GoodObject(i) || !name || !desc)
    return;
  
  if (!GoodObject(db[i].owner))
    return;
  
  /* Check if this warning is inhibited */
  x = buf;
  strncpy(buf, atr_get(i, A_WINHIBIT), sizeof(buf) - 1);
  buf[sizeof(buf) - 1] = '\0';
  
  while ((y = parse_up(&x, ' ')))
  {
    if (!string_compare(y, name) || !string_compare(y, "all"))
      return;  /* user doesn't want to hear about it for this object */
  }
  
  /* Send warning to owner */
  snprintf(buf, sizeof(buf), "Warning '%s' for %s: %s", 
           name, unparse_object(db[i].owner, i), desc);
  notify(db[i].owner, buf);

  /* Notify interested parties on channels */
  snprintf(buf, sizeof(buf), "* %s: %s", 
           unparse_object(db[i].owner, i), desc);
  com_send(tprintf("warn_%s", name), buf);
}

/* ===================================================================
 * Individual Check Functions
 * =================================================================== */

/**
 * Check if room has a description
 */
static void ct_roomdesc(dbref i)
{
  if (!GoodObject(i))
    return;
    
  if ((Typeof(i) == TYPE_ROOM) && !*atr_get(i, A_DESC))
    complain(i, "roomdesc", "Room has no description.");
}

/**
 * Check for one-way exits
 */
static void ct_onewayexit(dbref i)
{
  dbref j;

  if (!GoodObject(i))
    return;

  if ((Typeof(i) != TYPE_EXIT) || 
      (db[i].link == NOTHING) || 
      (Typeof(db[i].link) != TYPE_ROOM) || 
      db[i].link == db[i].location)
    return;
  
  if (!GoodObject(db[i].link))
    return;
  
  for (j = db[db[i].link].exits; j != NOTHING; j = db[j].next)
  {
    if (!GoodObject(j))
      break;
    if (db[j].link == db[i].location)
      return;
  }
  
  complain(i, "onewayexit", "Exit has no return exit.");
}

/**
 * Check for multiple return exits (double exit)
 */
static void ct_doubleexit(dbref i)
{
  dbref j;
  int count = 0;

  if (!GoodObject(i))
    return;

  if ((Typeof(i) != TYPE_EXIT) || 
      (db[i].link == NOTHING) || 
      (Typeof(db[i].link) != TYPE_ROOM) || 
      db[i].location == db[i].link)
    return;
  
  if (!GoodObject(db[i].link))
    return;
  
  for (j = db[db[i].link].exits; j != NOTHING; j = db[j].next)
  {
    if (!GoodObject(j))
      break;
    if (db[j].link == db[i].location)
      count++;
  }
  
  if (count > 1)
    complain(i, "doubleexit", "Exit has multiple return exits.");
}

/**
 * Check if exit has appropriate success/fail messages
 */
static void ct_exitmsgs(dbref i)
{
  int lt;

  if (!GoodObject(i))
    return;

  if ((Typeof(i) != TYPE_EXIT) || (db[i].flags & DARK))
    return;
    
  lt = lock_type(i, atr_get(i, A_LOCK));
  
  if ((lt != 1) && (!*atr_get(i, A_OSUCC) ||
                    !*atr_get(i, A_ODROP) ||
                    !*atr_get(i, A_SUCC)))
    complain(i, "exitmsgs", "Exit is missing one or more of osucc, odrop, succ.");
    
  if ((lt != 0) && (!*atr_get(i, A_OFAIL) ||
                    !*atr_get(i, A_FAIL)))
    complain(i, "exitmsgs", "Exit is missing one or more of fail, ofail.");
}

/**
 * Check if exit has a description
 */
static void ct_exitdesc(dbref i)
{
  if (!GoodObject(i))
    return;
    
  if ((Typeof(i) != TYPE_EXIT) || (db[i].flags & DARK))
    return;
    
  if (!*atr_get(i, A_DESC))
    complain(i, "exitdesc", "Exit is missing description.");
}

/**
 * Check if player has a description
 */
static void ct_playdesc(dbref i)
{
  if (!GoodObject(i))
    return;
    
  if (Typeof(i) != TYPE_PLAYER)
    return;
    
  if (!*atr_get(i, A_DESC))
    complain(i, "playdesc", "Player is missing description.");
}

/**
 * Check if thing has a description
 */
static void ct_thngdesc(dbref i)
{
  if (!GoodObject(i))
    return;
    
  if ((Typeof(i) != TYPE_THING) || (db[i].location == db[i].owner))
    return;
    
  if (!*atr_get(i, A_DESC))
    complain(i, "thngdesc", "Thing is missing description.");
}

/**
 * Check if thing has appropriate success/fail messages
 */
static void ct_thngmsgs(dbref i)
{
  int lt;

  if (!GoodObject(i))
    return;

  if ((Typeof(i) != TYPE_THING) || (db[i].location == db[i].owner))
    return;
    
  lt = lock_type(i, atr_get(i, A_LOCK));
  
  if ((lt != 1) && (!*atr_get(i, A_OSUCC) ||
                    !*atr_get(i, A_ODROP) ||
                    !*atr_get(i, A_SUCC) ||
                    !*atr_get(i, A_DROP)))
    complain(i, "thngmsgs", "Thing is missing one or more of osucc,odrop,succ,drop.");
    
  if ((lt != 0) && (!*atr_get(i, A_OFAIL) ||
                    !*atr_get(i, A_FAIL)))
    complain(i, "thngmsgs", "Thing is missing one or more of ofail,fail.");
}

/**
 * Check exit naming conventions
 */
static void ct_exitnames(dbref i)
{
  if (!GoodObject(i))
    return;
    
  /* To be implemented - check for proper exit naming */
  /* This was noted as "soon to be written" in original */
}

/**
 * Check for unlinked exits (security issue - anyone can steal)
 */
static void ct_nolinked(dbref i)
{
  if (!GoodObject(i))
    return;
    
  if ((Typeof(i) == TYPE_EXIT) && (db[i].link == NOTHING))
    complain(i, "nolinked", "Exit is unlinked; anyone can steal it.");
}

/**
 * Check for potential security vulnerabilities
 */
static void ct_security(dbref i)
{
  int j;
  ALIST *al;
  char *x;

  if (!GoodObject(i))
    return;

  /* Check parent relationships for wizbug insertion */
  if (db[i].parents)
  {
    for (j = 0; db[i].parents[j] != NOTHING; j++)
    {
      if (!GoodObject(db[i].parents[j]))
        continue;
        
      if (controls(i, db[i].parents[j], POW_MODIFY) &&
          !controls(db[i].parents[j], i, POW_MODIFY) &&
          !(db[i].flags & HAVEN && !db[i].children))
      {
        complain(i, "security", 
                tprintf("Wizbug may be inserted on parent %s.", 
                        unparse_object(db[db[i].parents[j]].owner, db[i].parents[j])));
      }
    }
  }
  
  /* Check for vulnerable attributes */
  if (db[i].list && !*atr_get(i, A_ULOCK) && Typeof(i) != TYPE_PLAYER)
  {
    for (al = db[i].list; al; al = AL_NEXT(al))
    {
      if (!AL_TYPE(al) || !AL_STR(al))
        continue;
        
      if (*AL_STR(al) != '$' && *AL_STR(al) != '!')
        continue;
      
      x = strchr(AL_STR(al), ':');
      if (!x)
        continue;
      
      /* Check for known dangerous patterns */
      if (!strncmp(AL_STR(al), "$bork *:", 8))
      {
        complain(i, "security", 
                tprintf("I bet draco has a wizbug on attribute %s.", 
                        unparse_attr(AL_TYPE(al), 0)));
        continue;
      }
      
      x++;
      if (*x == '/')
      {
        for (x++; *x != '/' && *x; x++)
          ;
        if (*x)
          x++;
      }
      
      /* Check for %0 vulnerability */
      if (!strncmp(x, "%0", 2) || !strncmp(x, "[v(0", 4))
      {
        complain(i, "security", 
                tprintf("Wizbug may be present on attribute %s.", 
                        unparse_attr(AL_TYPE(al), 0)));
        continue;
      }
      
      /* Check for @force with %0 */
      if (!strncmp(x, "@fo", 3))
      {
        for (; *x && *x != '='; x++)
          ;
        if (!*x)
          continue;
        x++;
        if (!strncmp(x, "%0", 2) || !strncmp(x, "[v(0", 4))
        {
          complain(i, "security", 
                  tprintf("Wizbug may be present on attribute %s.", 
                          unparse_attr(AL_TYPE(al), 0)));
          continue;
        }
      }
      else if (*x == '#')
      {
        for (; *x && *x != ' '; x++)
          ;
        if (!*x)
          continue;
        x++;
        if (!strncmp(x, "%0", 2) || !strncmp(x, "[v(0", 4))
        {
          complain(i, "security", 
                  tprintf("Wizbug may be present on attribute %s.", 
                          unparse_attr(AL_TYPE(al), 0)));
          continue;
        }
      }
    }
  }
}

/* ===================================================================
 * Group Check Functions
 * =================================================================== */

/**
 * Perform no checks
 */
static void ct_none(dbref i)
{
  /* do absolutely nothing */
}

/**
 * Perform only serious security checks
 */
static void ct_serious(dbref i)
{
  if (!GoodObject(i))
    return;
    
  ct_roomdesc(i);
  ct_nolinked(i);
  ct_security(i);
}

/**
 * Perform normal level of checks
 */
static void ct_normal(dbref i)
{
  if (!GoodObject(i))
    return;
    
  ct_playdesc(i);
  ct_roomdesc(i);
  ct_onewayexit(i);
  ct_doubleexit(i);
  ct_exitnames(i);
  ct_nolinked(i);
  ct_security(i);
}

/**
 * Perform extra checks
 */
static void ct_extra(dbref i)
{
  if (!GoodObject(i))
    return;
    
  ct_roomdesc(i);
  ct_onewayexit(i);
  ct_doubleexit(i);
  ct_playdesc(i);
  ct_exitmsgs(i);
  ct_thngdesc(i);
  ct_thngmsgs(i);
  ct_exitnames(i);
  ct_nolinked(i);
  ct_security(i);
}

/**
 * Perform all checks
 */
static void ct_all(dbref i)
{
  if (!GoodObject(i))
    return;
    
  ct_extra(i);
  ct_exitdesc(i);
}

/* ===================================================================
 * Main Check Functions
 * =================================================================== */

/**
 * Run topology checks on a specific object based on player's warning settings
 * @param i Object to check
 */
static void check_topology_on(dbref i)
{
  char buf[MAX_WARNING_BUFFER];
  char *x;
  char *y;
  int j;

  if (!GoodObject(i) || !GoodObject(db[i].owner))
    return;

  /* Get warning level for this player */
  x = buf;
  strncpy(buf, (*atr_get(db[i].owner, A_WARNINGS)) ? 
          atr_get(db[i].owner, A_WARNINGS) : "normal",
          sizeof(buf) - 1);
  buf[sizeof(buf) - 1] = '\0';
  
  /* Process each warning type */
  while ((y = parse_up(&x, ' ')))
  {
    for (j = 0; tchecks[j].name; j++)
    {
      if (!string_compare(tchecks[j].name, y))
      {
        (*tchecks[j].func)(i);
        break;
      }
    }
    
    if (!tchecks[j].name && Typeof(i) == TYPE_PLAYER)
      notify(i, tprintf("Unknown warning: %s", y));
  }
}

/**
 * Run periodic topology checks on database
 * Called from timer system
 */
void run_topology(void)
{
  int ndone;

  for (ndone = 0; ndone < warning_chunk; ndone++)
  {
    current_object++;
    if (current_object >= db_top)
      current_object = (dbref) 0;
      
    if (!GoodObject(current_object))
      continue;
      
    if (db[current_object].flags & GOING)
      continue;
    
    /* Check connected players' objects */
    if (db[db[current_object].owner].flags & CONNECT)
    {
      check_topology_on(current_object);
      ndone += warning_bonus;
    }
    /* Check powerful players' objects for security issues only */
    else if (get_pow(db[current_object].owner, POW_MODIFY) != PW_NO)
    {
      ct_security(current_object);
      ndone += warning_bonus;
    }
  }
}
